function exit_state_diff = SimExit(  topology, exit_param, symbol_likelihood, codeword, sim_param )
% SimExit simulates detector mutual information metrics
%
% The calling syntax is:
%     exit_state_diff = SimExit( exit_param, symbol_likelihood, codeword )
%
%     Inputs
%     exit_param = exit analysis parameters
%     symbol_likelihood = vector of symbol log-likelihoods
%     codeword               = codeword bits generated by source
%
%     Outputs
%     exit_state_diff     = updated detector mutual information metrics
%     Note: See readme.txt for a description of the structure formats.
%
%     Copyright (C) 2012, Xingyu Xiang, Terry Ferrett and Matthew C. Valenti
%
%     Last updated on 9/4/2012

switch exit_param.exit_type,
    
    case 'ldpc',
        if strcmp(topology, 'p2p')
        [IA_det IE_det] = compute_detector_mi_p2p( codeword, symbol_likelihood, exit_param.requested_IA );
        elseif strcmp(topology, 'twrc')
            [IA_det IE_det] = compute_detector_mi_twrc( codeword, symbol_likelihood, ...
                exit_param.requested_IA, sim_param );
        end
        exit_state_diff.IA_det = IA_det;
        exit_state_diff.IE_det = IE_det;
        
    case 'turboproc',
        
    otherwise,
        
end
end




function [IA_det IE_det] = compute_detector_mi_p2p( codeword, symbol_likelihood, requested_IA)
len_IA = length( requested_IA );


IA_det = zeros(1, len_IA);
IE_det = zeros(1, len_IA);
for IA_index = 1:len_IA
    sigma = invJ1(requested_IA(IA_index));
    
    %%% generate normally distributed aprior inputs
    llrs = randn(1,length(codeword))*sigma + (codeword-0.5)*sigma^2;    % test + or -
    
    %%%% perform soft demapping using normally distributed llrs
    bit_likelihood = Somap( symbol_likelihood, 0, llrs);
    
    %%%% compute mutual information before and after soft-mapping stage
    IA_det(IA_index) = Capacity( llrs, codeword);
    IE_det(IA_index) = Capacity( bit_likelihood, codeword);
    
end
end


function [IA_det IE_det] = compute_detector_mi_twrc( codeword, symbol_likelihood, requested_IA, sim_param)
len_IA = length( requested_IA );

IA_det = zeros(1, len_IA);
IE_det = zeros(1, len_IA);

for IA_index = 1:len_IA
    sigma = invJ1(requested_IA(IA_index));
    
    %%% generate normally distributed aprior inputs
    llrs = randn(1,length(codeword))*sigma + (codeword-0.5)*sigma^2;    % test + or -
    
    %%%% perform soft demapping using normally distributed llrs
    [ bit_likelihood ] = CmlTwrcRelaySomap( symbol_likelihood, llrs, sim_param );
        
    %%%% compute mutual information before and after soft-mapping stage
    IA_det(IA_index) = Capacity( llrs, codeword);
    IE_det(IA_index) = Capacity( bit_likelihood, codeword);
    
end
end


%     Function SimExit is part of the Iterative Solutions Coded Modulation
%     Library (ISCML).
%
%     The Iterative Solutions Coded Modulation Library is free software;
%     you can redistribute it and/or modify it under the terms of
%     the GNU Lesser General Public License as published by the
%     Free Software Foundation; either version 2.1 of the License,
%     or (at your option) any later version.
%
%     This library is distributed in the hope that it will be useful,
%     but WITHOUT ANY WARRANTY; without even the implied warranty of
%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
%     Lesser General Public License for more details.
%
%     You should have received a copy of the GNU Lesser General Public
%     License along with this library; if not, write to the Free Software
%     Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

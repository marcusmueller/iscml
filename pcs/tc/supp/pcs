#!/bin/bash
### BEGIN INIT INFO 
# Provides:        pcs    
# Short Description: Management script for pcs suite                                                   
### END INIT INFO                                                                                                                                 #     Copyright (C) 2012, Terry Ferrett and Matthew C. Valenti
#     For full copyright information see the bottom of this file.
#
#
# Startup script for Parallel Computing Suite (PCS)
# 
#
# Command syntax
# > pcs {short|long|testing} {start|stop|shutdown|restart}
#
# where 
#   Argument 1   Queue Type
#   Argument 2   Daemon action
#
#   = Queue Type =
#   
#   short    used for short-running tasks
#            The CML job manager executes in this queue
#
#   long     used for long running tasks
#            by default no job manager services this queue
#
#   testing  used to test the CML job manager
#
#  
#   = Daemon Action =
#
#   start     clear all global queues                                                                             
#             start task controllers, worker controllers, workers                                                 
#                                     
#   stop      stop all controllers and workers                                                                    
#             save state of global queues                                                                         
#                                                                                                                                                 #    
#   resume    restore state of global queues at time of last stop                                                 
#             start all controllers and workers                                                                   
#
#   shutdown  allow tasks in global queue to complete                                                             
#             stop all controllers and workers                                                                    
#
#
#   = Examples =
# 
#   Start the short queue and long queue daemons
#   > pcs short start
#   > pcs long start
#    
#
#   Stop the short queue
#   > pcs short stop
#   
#####



### functions for testing inputs ######
# echo input error and return
eie_ret(){
echo "Improper input arguments."
echo "Usage:"
echo "pcs {short|long|testing} {stop|start|resume|shutdown}"
exit 2
}

# check input action
cia(){
case $1 in
start)
echo "start"
;;
stop)
echo "stop"
;;
resume)
echo "resume"
;;
shutdown)
echo "shutdown"
;;
*)
eie_ret
esac
}


# check testing parameter
cq(){
case $1 in
short)
echo "short"
;;
long)
echo "long"
;;
testing)
echo "testing"
;;
*)
eie_ret
esac
}
#####################################




###process input arguments #########

#check for proper number of input arguments
if [ $# -ne 2 ]
then
eie_ret
fi


Q=$(cq $1)    # read requested queue
IA=$(cia $2)  # read input argument
##########################




### paths can remain hard coded
### paths #########                                                                                                                               
# task and worker controllers
PATH_TC=/home/pcs/tc/ctc/src
PATH_WC=/home/pcs/tc/cwc/src

# job managers
PATH_CML_JM=/home/pcs/jm/cml/src

CFGP=/home/pcs/tc/cfg
#####################


# configuration files                                                                                                                             
scfg='pcs_short_384.cfg'   # short queue
lcfg='pcs_long_384.cfg'    # long queue
tcfg='pcs_test.cfg'        # testing queue
#####################                                                                                                                             


# based on queue assign names
case $Q in
short)
TC=stc
WC=swc
JM=CmlJm
cfg=$scfg
jmcfg='/home/pcs/jm/cml/cfg/CmlJobManager_cfg'
LOCKFILE=/home/pcs/tc/supp/lock/spcs_lock
;;
long)
TC=ltc
WC=lwc
JM=
cfg=$lcfg
jmcfg=
LOCKFILE=/home/pcs/tc/supp/lock/lpcs_lock
;;
testing)
TC=ttc
WC=twc
JM=TCmlJm
cfg=$tcfg
jmcfg='/home/pcs/jm/cml/cfg/TCmlJobManager_cfg'
LOCKFILE=/home/pcs/tc/supp/lock/tpcs_lock
;;
esac


# read config files
### read queues from config files
get_cfg_val(){
file=$1
key=$2
awk -vk="$key" -F"=" '$1~k{ print $2}' $file
}


file=$CFGP/$cfg
PATH_IQ=$(get_cfg_val $file input_queue)
PATH_RQ=$(get_cfg_val $file run_queue)
PATH_OQ=$(get_cfg_val $file output_queue)




# error messages
LOCKFILE_EXISTS_ERR="PCS $Q is already running."
LOCKFILE_DOESNOTEXIST_ERR="PCS $Q is not running.  Execute 'pcs $Q {start|restart}' to start the service."
##########################




#### functions                                                                                                
start_job_managers(){
TJM=$1
thisjmcfg=$2
if [ ! -z "$TJM" ]
then
screen -S $TJM -m -d matlab -r "cd $PATH_CML_JM; cml_jm_startup('$thisjmcfg')"
fi
}

     
start_workers(){
WC=$1
CFG=$2
screen -S $WC -m -d matlab -r "cd $PATH_WC; cwcobj = startup_wc('$CFG'); cwcobj.cSta"
}


stop_screen_session(){
screen -ls |grep $1 | awk -F . '{print $1}' |xargs kill >/dev/null
}


stop_workers(){
WC=$1
CFG=$2

screen -S $WC -m -d matlab -r "cd $PATH_WC; cwcobj = startup_wc('$CFG')"
sleep 5
screen -S $WC -p 0 -X eval 'stuff "\003"'
screen -S $WC -p 0 -X eval 'stuff "cwcobj.slay\015"'
sleep 3
stop_screen_session $WC
}


manage_controllers(){
TC=$1
CFG=$2
ss=$3

screen -S $TC -m -d matlab -r "cd $PATH_TC;tc_startup('$CFG','$ss')"
}


pidof_pcs() {
        # if there is a pcs process whose pid is in PIDFILE,                                                                              
        # print it and return 0.                                                                                                                        
        if [ -e "$PIDFILE" ]; then
                if pidof apache2 | tr ' ' '\n' | grep -w $(cat $PIDFILE); then
                        return 0
                fi
        fi
        return 1
}


wait_for_queue_to_empty(){
    while [ "$(ls -A  $1/*.mat 2>/dev/null)" ]
    do
        sleep 2
    done
       
}


does_lockfile_exist(){
    if [ -e $1 ]; then
	echo "1"
    else
	echo "0"
    fi
}


# if statement for testing
lockfile_exists=$(does_lockfile_exist $LOCKFILE)

case $IA in
    start)

	if [ $lockfile_exists -eq 0 ]; then
	    start_workers $WC $cfg  
            manage_controllers $TC $cfg start 
	    start_job_managers $JM $jmcfg
	    touch $LOCKFILE
	else
	    echo $LOCKFILE_EXISTS_ERR
	fi
	;; 

    restart)
        $0 stop && sleep 5 && $0 start
	;;

    resume)
	if [ $lockfile_exists -eq 0 ]; then
	    start_workers $WC $cfg
	    manage_controllers $TC $cfg resume
	    touch $LOCKFILE
	else
	    echo $LOCKFILE_EXISTS_ERR
	fi
	;;

    stop)
	if [ $lockfile_exists -eq 1 ]; then

	    stop_screen_session $WC
	    stop_screen_session $TC
	    stop_screen_session $JM
 
	    stop_workers $WC $cfg
	    
	    manage_controllers $TC $cfg stop

	    rm $LOCKFILE
	else
	    echo $LOCKFILE_DOESNOTEXIST_ERR
	fi
	;;

    shutdown)
	if [ $lockfile_exists -eq 1 ]; then

        stop_screen_session $TC
	stop_screen_session $JM
	
        manage_controllers $TC $cfg shutdown
	
	wait_for_queue_to_empty $PATH_IQ
	wait_for_queue_to_empty $PATH_RQ
	wait_for_queue_to_empty $PATH_OQ
	
        stop_screen_session $WC
	
        stop_workers $WC $cfg
	
	rm $LOCKFILE
	else
	    echo $LOCKFILE_DOESNOTEXIST_ERR
	fi
	;;

    *)
	echo "Usage: $0 {start|stop|restart|resume|shutdown}"
	exit 2
	;;
esac



